{
  "sections": [
    {
      "name": "Introduction and Algorithm Analysis",
      "number": "1",
      "topics": [
        {
          "name": "Fundamentals of Algorithms",
          "number": "1.1",
          "concepts": [
            {
              "name": "What is an Algorithm?",
              "description": "Definition, properties (finiteness, definiteness, input, output, effectiveness).",
              "connections": [
                2,
                3,
                4,
                5
              ]
            },
            {
              "name": "Problem Solving with Algorithms",
              "description": "Steps: problem definition, algorithm design, implementation, testing, analysis.",
              "connections": [
                1,
                3,
                4,
                5
              ]
            },
            {
              "name": "Pseudocode and Basic Control Structures",
              "description": "Writing clear algorithms using sequence, selection, and iteration.",
              "connections": [
                1,
                2,
                7,
                8
              ]
            }
          ]
        },
        {
          "name": "Algorithm Analysis",
          "number": "1.2",
          "concepts": [
            {
              "name": "Asymptotic Notation",
              "description": "Big-O, Big-Omega, Big-Theta; defining upper, lower, and tight bounds.",
              "connections": [
                5,
                6,
                14,
                30
              ]
            },
            {
              "name": "Time and Space Complexity",
              "description": "Analyzing worst-case, average-case, and best-case runtime and memory usage.",
              "connections": [
                4,
                6,
                14,
                19
              ]
            },
            {
              "name": "Analyzing Iterative and Recursive Algorithms",
              "description": "Summation for loops; solving recurrence relations (e.g., Master Theorem) for recursion.",
              "connections": [
                4,
                5,
                15,
                16
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Fundamental Data Structures",
      "number": "2",
      "topics": [
        {
          "name": "Arrays and Linked Lists",
          "number": "2.1",
          "concepts": [
            {
              "name": "Arrays",
              "description": "Static and dynamic arrays, memory representation, access, insertion, deletion.",
              "connections": [
                8,
                9,
                10,
                21
              ]
            },
            {
              "name": "Singly, Doubly, and Circular Linked Lists",
              "description": "Node structure, traversal, insertion, deletion; comparing advantages/disadvantages vs. arrays.",
              "connections": [
                7,
                9,
                10,
                18
              ]
            }
          ]
        },
        {
          "name": "Stacks and Queues",
          "number": "2.2",
          "concepts": [
            {
              "name": "Stack ADT",
              "description": "LIFO principle, push, pop, peek; implementations using array and linked list.",
              "connections": [
                7,
                8,
                10,
                16
              ]
            },
            {
              "name": "Queue ADT",
              "description": "FIFO principle, enqueue, dequeue; implementations (array, linked list).",
              "connections": [
                7,
                8,
                9,
                11
              ]
            },
            {
              "name": "Deque and Priority Queue",
              "description": "Double-ended queue; priority queue concept and simple implementations.",
              "connections": [
                10,
                22,
                23,
                29
              ]
            }
          ]
        },
        {
          "name": "Hash Tables",
          "number": "2.3",
          "concepts": [
            {
              "name": "Hash Functions",
              "description": "Properties of a good hash function, common hash functions for integers/strings.",
              "connections": [
                13,
                14
              ]
            },
            {
              "name": "Collision Resolution",
              "description": "Separate Chaining and Open Addressing (Linear Probing, Quadratic Probing, Double Hashing).",
              "connections": [
                12,
                14
              ]
            },
            {
              "name": "Time Complexity Analysis",
              "description": "Analyzing search, insert, delete under average and worst-case assumptions.",
              "connections": [
                4,
                5,
                12,
                13
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Recursion and Advanced Data Structures",
      "number": "3",
      "topics": [
        {
          "name": "Recursion",
          "number": "3.1",
          "concepts": [
            {
              "name": "Principles of Recursion",
              "description": "Base case, recursive case, call stack, solving problems recursively.",
              "connections": [
                6,
                16,
                17,
                18
              ]
            },
            {
              "name": "Tree and Graph Traversal Recursively",
              "description": "Applying recursion to traverse hierarchical structures like trees.",
              "connections": [
                15,
                18,
                25
              ]
            },
            {
              "name": "Backtracking Algorithms",
              "description": "Solving problems like N-Queens, Sudoku by trying possibilities and undoing (backtracking) failures.",
              "connections": [
                15,
                16
              ]
            }
          ]
        },
        {
          "name": "Trees",
          "number": "3.2",
          "concepts": [
            {
              "name": "Tree Terminology and Binary Trees",
              "description": "Root, node, leaf, height, depth; binary tree properties and traversals (in-order, pre-order, post-order).",
              "connections": [
                16,
                19,
                21,
                24
              ]
            },
            {
              "name": "Binary Search Trees (BST)",
              "description": "BST property, search, insertion, deletion; time complexity analysis.",
              "connections": [
                5,
                18,
                20
              ]
            },
            {
              "name": "Balanced BSTs (AVL Trees)",
              "description": "Concept of balance, rotations (single, double) to maintain AVL property.",
              "connections": [
                19
              ]
            }
          ]
        },
        {
          "name": "Heaps",
          "number": "3.3",
          "concepts": [
            {
              "name": "Binary Heap Structure",
              "description": "Complete binary tree, heap order property (min-heap, max-heap).",
              "connections": [
                18,
                22,
                23
              ]
            },
            {
              "name": "Heap Operations",
              "description": "Insert (bubble-up), extract-min/max (bubble-down), heapify.",
              "connections": [
                21,
                23
              ]
            },
            {
              "name": "Applications of Heaps",
              "description": "Heap Sort algorithm, Priority Queue implementation.",
              "connections": [
                21,
                22,
                30
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Graph Algorithms",
      "number": "4",
      "topics": [
        {
          "name": "Graph Fundamentals",
          "number": "4.1",
          "concepts": [
            {
              "name": "Graph Terminology and Representations",
              "description": "Vertices, edges, directed/undirected, weighted/unweighted; adjacency matrix and adjacency list.",
              "connections": [
                18,
                25,
                26,
                27
              ]
            },
            {
              "name": "Graph Traversal Algorithms",
              "description": "Breadth-First Search (BFS) and Depth-First Search (DFS); applications and time complexity.",
              "connections": [
                16,
                24,
                26,
                27
              ]
            }
          ]
        },
        {
          "name": "Shortest Path Problems",
          "number": "4.2",
          "concepts": [
            {
              "name": "Dijkstra's Algorithm",
              "description": "Finding shortest paths from a single source in weighted graphs (non-negative weights).",
              "connections": [
                24,
                25,
                27
              ]
            },
            {
              "name": "Bellman-Ford Algorithm",
              "description": "Finding shortest paths from a single source, can handle negative weight edges (detects negative cycles).",
              "connections": [
                24,
                25,
                26
              ]
            }
          ]
        },
        {
          "name": "Minimum Spanning Tree (MST)",
          "number": "4.3",
          "concepts": [
            {
              "name": "Kruskal's Algorithm",
              "description": "Greedy algorithm using a union-find (disjoint set) data structure to build MST.",
              "connections": [
                24,
                29
              ]
            },
            {
              "name": "Prim's Algorithm",
              "description": "Greedy algorithm growing the MST from an arbitrary starting vertex, typically using a priority queue.",
              "connections": [
                11,
                23,
                24,
                28
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "Algorithm Design Techniques",
      "number": "5",
      "topics": [
        {
          "name": "Sorting Algorithms",
          "number": "5.1",
          "concepts": [
            {
              "name": "Elementary Sorts",
              "description": "Bubble Sort, Selection Sort, Insertion Sort; analysis and comparison.",
              "connections": [
                4,
                5,
                23
              ]
            },
            {
              "name": "Divide-and-Conquer Sorts",
              "description": "Merge Sort (stable, O(n log n)) and Quick Sort (in-place, average-case O(n log n)).",
              "connections": [
                30,
                32,
                5,
                37,
                4
              ]
            }
          ]
        },
        {
          "name": "Divide and Conquer",
          "number": "5.2",
          "concepts": [
            {
              "name": "Paradigm Overview",
              "description": "Divide problem into subproblems, conquer subproblems, combine results.",
              "connections": [
                15,
                33,
                36,
                4,
                6
              ]
            },
            {
              "name": "Example Problems",
              "description": "Binary Search, finding maximum subarray sum, Strassen's matrix multiplication.",
              "connections": [
                32,
                19,
                7,
                8,
                15
              ]
            }
          ]
        },
        {
          "name": "Greedy Algorithms",
          "number": "5.3",
          "concepts": [
            {
              "name": "Greedy Choice Property",
              "description": "Making the locally optimal choice at each stage with the hope of a global optimum.",
              "connections": [
                35,
                36,
                4,
                5,
                40
              ]
            },
            {
              "name": "Example Problems",
              "description": "Activity Selection, Huffman Coding, Fractional Knapsack.",
              "connections": [
                34,
                23,
                26,
                29,
                28
              ]
            }
          ]
        },
        {
          "name": "Dynamic Programming",
          "number": "5.4",
          "concepts": [
            {
              "name": "Principle of Optimality",
              "description": "Breaking problems into overlapping subproblems and storing results (memoization).",
              "connections": [
                37,
                38,
                15,
                4,
                5
              ]
            },
            {
              "name": "Tabulation vs Memoization",
              "description": "Bottom-up (table filling) and top-down (recursive with cache) approaches.",
              "connections": [
                36,
                38,
                15,
                4,
                5
              ]
            },
            {
              "name": "Classic Problems",
              "description": "Fibonacci, 0/1 Knapsack, Longest Common Subsequence, Coin Change.",
              "connections": [
                36,
                37,
                4,
                5,
                40
              ]
            }
          ]
        }
      ]
    }
  ]
}